trigger: none
#  branches:
#    include:
#      - main

pr: none
#  branches:
#    include:
#     - main
#  paths:
#    include:
#      - Database/MSSQL_Server/Dev/conf/rollback_input.csv
      
pool:
  name: Self-Hosted

variables:
  DB_SERVER: 'localhost'
  DB_NAME: 'Payroll'  

stages:
###################################################################################
- stage: DetectFallbackScripts
  displayName: 'Detect Fallback Rollback Scripts in CSV'
  jobs:
  - job: DetectFallback
    displayName: 'Detect Fallbacks from CSV'
    steps:
    - task: PowerShell@2
      name: DetectFallbackPresence
      inputs:
        targetType: 'inline'
        script: |
          $CsvPath = "$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/conf/rollback_input.csv"
          if (-not (Test-Path $CsvPath)) {
            Write-Error "CSV file not found: $CsvPath"
            exit 1
          }

          $csv = Import-Csv -Path $CsvPath
          Write-Host "Imported $($csv.Count) rows from CSV."
          $hasFallback = $false

          foreach ($row in $csv) {
            Write-Host "Checking row with PR_ID: $($row.PR_ID), FallbackRollbackScript: $($row.FallbackRollbackScript)"
            if ($row.FallbackRollbackScript -and $row.FallbackRollbackScript.Trim() -ne "") {
              Write-Host "Found fallback rollback script in this row."
              $hasFallback = $true
              break
            }
          }

          if ($hasFallback) {
            Write-Host "Fallback rollback scripts detected in CSV."
            Write-Host "##vso[task.setvariable variable=FallbackRollbackScriptPresent;isOutput=true]true"
          } else {
            Write-Host "No fallback rollback scripts found in CSV."
            Write-Host "##vso[task.setvariable variable=FallbackRollbackScriptPresent;isOutput=true]false"
          }
###################################################################################
- stage: UpdateMapperTable
  displayName: 'Update Mapper Table with Ad-hoc Rollbacks (Conditional)'
  dependsOn: DetectFallbackScripts
  condition: eq(dependencies.DetectFallbackScripts.outputs['DetectFallback.DetectFallbackPresence.FallbackRollbackScriptPresent'], 'true') 
  jobs:
  - job: UpdateMapper
    pool:
      name: Self-Hosted
    steps:
    - task: PowerShell@2
      name: UpdateMapperTable
      displayName: 'Insert Ad-hoc Rollback Mappings'
      inputs:
        targetType: 'inline'
        script: |
          $CsvPath = "$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/conf/rollback_input.csv"
          if (-not (Test-Path $CsvPath)) {
            Write-Error "CSV file not found: $CsvPath"
            exit 1
          }
          $requests = Import-Csv -Path $CsvPath
          if ($requests.Count -eq 0) {
            Write-Error "No rows found in CSV"
            exit 1
          }
          [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
          $conn = New-Object System.Data.SqlClient.SqlConnection
          $conn.ConnectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
          $conn.Open()
          foreach ($item in $requests) {
            $prId = $item.PR_ID
            $version = $item.MigrationVersion
            $fallbackScriptFull = $item.FallbackRollbackScript.Trim()
            if ($null -ne $fallbackScriptFull -and $fallbackScriptFull -ne "") {
              $fallbackScript = [System.IO.Path]::GetFileName($fallbackScriptFull)
              $rollbackScriptPath = Join-Path -Path "$(Build.SourcesDirectory)" -ChildPath $fallbackScriptFull  
              if (Test-Path $rollbackScriptPath) {
                $cmd = $conn.CreateCommand()
                $cmd.CommandText = "SELECT COUNT(*) FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND migration_version = @version"
                $cmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                $cmd.Parameters.AddWithValue("@version", $version) | Out-Null
                $exists = $cmd.ExecuteScalar()
                if ($exists -eq 0) {
                  $majorVersion = $version.Split('.')[0]
                  $migrationScriptValue = "ad-hoc-V$majorVersion"
                  $insertCmd = $conn.CreateCommand()
                  $insertCmd.CommandText = "INSERT INTO Payroll.dbo.migration_rollback_mapper (pr_id, migration_version, rollback_script_name, migration_script, rollback_script_repo_folder, rollback_script_repo_url) VALUES (@prId, @version, @rollbackScript, @migrationScript, @repoFolder, @repoUrl)"
                  $insertCmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
                  $insertCmd.Parameters.AddWithValue("@version", $version) | Out-Null
                  $insertCmd.Parameters.AddWithValue("@rollbackScript", $fallbackScript) | Out-Null
                  $insertCmd.Parameters.AddWithValue("@migrationScript", $migrationScriptValue) | Out-Null
                  $insertCmd.Parameters.AddWithValue("@repoFolder", "Database/MSSQL_Server/Dev/rollback_sql") | Out-Null
                  $insertCmd.Parameters.AddWithValue("@repoUrl", "https://github.com/ktsreddy007/DB_Migrotron") | Out-Null
                  $insertCmd.ExecuteNonQuery()
                  Write-Host "Inserted new rollback mapping for PR $prId, version $version with fallback rollback script: $fallbackScript and migration_script: $migrationScriptValue"
                }
              }          
              else {
                Write-Warning "Fallback rollback script file NOT found in repo: $fallbackScriptFull. Skipping insert."
              }
            }
          }           
          $conn.Close()
      env:
        dbUser: $(dbUser_1)
        dbPassword: $(dbPassword)
###################################################################################
- stage: FetchRollbackScripts
  displayName: 'Fetch Rollback Scripts and Publish Artifact'
  condition: or(
    succeeded('UpdateMapperTable'),
    eq(dependencies.UpdateMapperTable.result, 'skipped')
    )
  jobs:
  - job: FetchScripts
    pool:
      name: Self-Hosted
    steps:
    - task: PowerShell@2
      name: FetchRollbackScripts
      displayName: 'Fetch rollback scripts based on mapper table'
      inputs:
        targetType: 'inline'
        script: |
          $CsvPath = "$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/conf/rollback_input.csv"
          if (-not (Test-Path $CsvPath)) {
            Write-Error "CSV file not found: $CsvPath"
            exit 1
          }
          $requests = Import-Csv -Path $CsvPath
          if ($requests.Count -eq 0) {
            Write-Error "No rows found in CSV"
            exit 1
          }

          [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
          $conn = New-Object System.Data.SqlClient.SqlConnection
          $conn.ConnectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
          $conn.Open()

          $grouped = $requests | Group-Object PR_ID
          foreach ($group in $grouped) {
            $prId = $group.Name
            $rollbackScripts = @()
            foreach ($item in $group.Group) {
              $version = $item.MigrationVersion
              Write-Host "Fetching rollback for PR: $prId, Version: $version"
              $cmd = $conn.CreateCommand()
              $cmd.CommandText = "SELECT rollback_script_name, migration_script FROM Payroll.dbo.migration_rollback_mapper WHERE pr_id = @prId AND migration_version = @version ORDER BY rollback_script_name DESC"
              $cmd.Parameters.Clear()
              $cmd.Parameters.AddWithValue("@prId", $prId) | Out-Null
              $cmd.Parameters.AddWithValue("@version", $version) | Out-Null
              $reader = $cmd.ExecuteReader()
              while ($reader.Read()) {
                $rollbackScripts += [PSCustomObject]@{
                  RollbackFile = $reader["rollback_script_name"]
                  MigrationFile = $reader["migration_script"]
                }
              }
              $reader.Close()
            }
            if ($rollbackScripts.Count -eq 0) {
              Write-Warning "No rollback scripts found for PR: $prId"
              continue
            }
            $timestamp = Get-Date -Format "yyyyMMddHHmmss"
            $jsonFileName = "PR${prId}_MIRO_Mapperdata_$timestamp.json"
            $jsonPath = Join-Path -Path "$(Build.ArtifactStagingDirectory)" -ChildPath $jsonFileName
            $rollbackScripts | ConvertTo-Json -Depth 3 | Out-File -FilePath $jsonPath -Encoding utf8
            Write-Host "Created JSON for PR: $prId -> $jsonFileName"
          }

          $conn.Close()
      env:
        dbUser: $(dbUser_1)
        dbPassword: $(dbPassword)

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: RollbackScriptsArtifact
###################################################################################
- stage: DependencyChecker
  displayName: 'Check Dependencies'
  dependsOn: FetchRollbackScripts
  condition: succeeded('FetchRollbackScripts')
  jobs:
    - job: AnalyzeDependencies
      steps:
        - download: current
          artifact: RollbackScriptsArtifact
        - task: PowerShell@2
          displayName: 'Analyze DDL & DML Dependencies'
          inputs:
            targetType: 'inline'
            script: |
              Write-Host "Analyzing object dependencies for safe rollback..."
              [System.Reflection.Assembly]::LoadWithPartialName("System.Data.SqlClient") | Out-Null
              $connection = New-Object System.Data.SqlClient.SqlConnection
              $connection.ConnectionString = "Server=$(DB_SERVER);Database=$(DB_NAME);User Id=$env:dbUser;Password=$env:dbPassword;"
              $connection.Open()
              $artifactPath = "$(Pipeline.Workspace)/RollbackScriptsArtifact"
              $jsonFiles = Get-ChildItem -Path $artifactPath -Filter "PR*_MIRO_Mapperdata_*.json"
              if ($jsonFiles.Count -eq 0) {
                Write-Error "No rollback JSON files found in artifact path: $artifactPath"
                exit 1
              }
              $ddlDeps = @()
              $dmlDeps = @()
              foreach ($jsonFile in $jsonFiles) {
                $jsonContent = Get-Content -Raw -Path $jsonFile.FullName | ConvertFrom-Json
                foreach ($scriptObj in $jsonContent) {
                  $rollbackFile = $scriptObj.RollbackFile
                  $filePath = "$(Build.SourcesDirectory)/Database/MSSQL_Server/Dev/rollback_sql/$rollbackFile"
                  if (-Not (Test-Path $filePath)) {
                    Write-Warning "File not found: $filePath"
                    continue
                  }
                  $content = Get-Content $filePath | Where-Object { $_ -notmatch "^\s*--" -and $_ -ne "" }
                  foreach ($line in $content) {
                    Write-Host "Line: $line"
                    if ($line -match "(?i)\bINSERT\s+INTO\s+\[?(\w+)\]?") {
                      Write-Host "Detected INSERT into table: $($matches[1])"
                      $dmlDeps += $matches[1]
                    } elseif ($line -match "(?i)\bUPDATE\s+\[?(\w+)\]?") {
                      Write-Host "Detected UPDATE on table: $($matches[1])"
                      $dmlDeps += $matches[1]
                    } elseif ($line -match "(?i)\bDELETE\s+FROM\s+\[?(\w+)\]?") {
                      Write-Host "Detected DELETE from table: $($matches[1])"
                      $dmlDeps += $matches[1]
                    }
                    if ($line -match "(?i)(CREATE|ALTER|DROP)\s+TABLE\s+(?:IF EXISTS\s+)?([a-zA-Z0-9_\[\]\.]+)") {
                      $normalizedName = $matches[2] -replace '\[|\]', ''
                      Write-Host "Detected DDL on table: $normalizedName"
                      $ddlDeps += $normalizedName
                    }
                  }
                }
              }
              $dmlDeps = $dmlDeps | Sort-Object -Unique
              $ddlDeps = $ddlDeps | Sort-Object -Unique
              Write-Host "DML Dependencies Detected: $($dmlDeps -join ', ')"
              Write-Host "DDL Dependencies Detected: $($ddlDeps -join ', ')"
              if ($dmlDeps.Count -gt 0) {
                $depsStr = ($dmlDeps | ForEach-Object { "'$_'" }) -join ","
                $fkQuery = "SELECT tp.name AS ParentTable, tr.name AS ReferencedTable FROM sys.foreign_keys fk JOIN sys.tables tp ON fk.parent_object_id = tp.object_id JOIN sys.tables tr ON fk.referenced_object_id = tr.object_id WHERE tp.name IN ($depsStr) OR tr.name IN ($depsStr)"
                $command = $connection.CreateCommand()
                $command.CommandText = $fkQuery
                $reader = $command.ExecuteReader()
                $fkList = @()
                while ($reader.Read()) {
                  $fkList += [PSCustomObject]@{
                    Parent = $reader["ParentTable"]
                    Child = $reader["ReferencedTable"]
                  }
                }
                $reader.Close()
                if ($fkList.Count -gt 0) {
                  Write-Host "DML dependency order (child -> parent) calculated:"
                  $fkList | ForEach-Object {
                    Write-Host "$($_.Child) -> $($_.Parent)"
                  }
                } else {
                  Write-Host "No foreign key dependencies found for provided DML tables."
                }
              } else {
                Write-Host "No DML dependencies to analyze."
              }
              $connection.Close()
          env:
            dbUser: $(dbUser_1)
            dbPassword: $(dbPassword)